Andrew Sneap and Ohad Kammar

Various actions on the reals

\begin{code}
{-# OPTIONS --without-K --exact-split --no-sized-types --no-guardedness --auto-inline --lossy-unification --allow-unsolved-metas #-} --safe

-- TODO: remove unnecessary dependencies

open import MLTT.Spartan renaming (_+_ to _‚àî_)

open import Notation.CanonicalMap
open import Notation.Order
open import UF.PropTrunc
open import MLTT.Sigma
open import Notation.General

open import UF.Subsingletons
open import UF.Subsingletons-FunExt
open import UF.FunExt
open import UF.Equiv
open import UF.Powerset
open import UF.UniverseEmbedding

-- ought to not be needed eventually
open import UF.Univalence

open import Rationals.Type
open import Rationals.Order
open import Rationals.FractionsOrder

open import Integers.Type
open import Integers.Order

open import Groups.Type
open import Groups.GroupActions
open import Groups.Subgroups

open import MLTT.Id

open import DedekindReals.Symmetry.UF
open import DedekindReals.Symmetry.IndexedAction
open import DedekindReals.Symmetry.ActionsConstructions
open import DedekindReals.Symmetry.Equivariance
open import DedekindReals.Symmetry.S2
open import DedekindReals.Symmetry.GroupProperties

open import DedekindReals.Symmetry.Transitive

module DedekindReals.Symmetry.Reals.Actions
 (pe : Prop-Ext)
 (pt : propositional-truncations-exist)
 (fe : Fun-Ext)
 {ùì§ : Universe} where

   open DedekindReals.Symmetry.UF.SurelyThisExistsSomewhere pe fe
   open import DedekindReals.Symmetry.MetaRelations pe pt fe
   open SetConstructions ‚Ñö (‚Ñö-is-set fe)
   open import DedekindReals.Symmetry.Relations-S2 pe pt fe
   open SetConstructions-S2 ‚Ñö (‚Ñö-is-set fe)
   open import DedekindReals.Type pe pt fe
   open PropositionalTruncation pt

   open import DedekindReals.Symmetry.Cuts pe pt fe ‚Ñö (‚Ñö-is-set fe)
   open import DedekindReals.Symmetry.Reals.Type pe pt fe {ùì§}
   open import DedekindReals.Symmetry.Transport pe fe


   open import Rationals.Addition renaming (_+_ to _‚Ñö+_)
   open import Rationals.Negation
   open import Rationals.Multiplication renaming (_*_ to _‚Ñö*_)

   -- First, let's define some symmetries on the reals
   additive-‚Ñö : Group ùì§‚ÇÄ
   additive-‚Ñö
     = ‚Ñö
     , _‚Ñö+_
     , ‚Ñö-is-set fe
     , ‚Ñö+-assoc fe
     , 0‚Ñö
     , ‚Ñö-zero-left-neutral fe
     , ‚Ñö-zero-right-neutral fe
     , Œª p ‚Üí (- p)
           , (‚Ñö-inverse-sum-to-zero' fe p)
           , (‚Ñö-inverse-sum-to-zero  fe p)

   ‚Ñö‚àò : ùì§‚ÇÄ Ãá
   ‚Ñö‚àò = Œ£ p Íûâ ‚Ñö , p ‚â† 0‚Ñö

   ‚Ñö‚àò-is-set : is-set ‚Ñö‚àò
   ‚Ñö‚àò-is-set = sigma-is-set (‚Ñö-is-set fe)
     Œª q ‚Üí props-are-sets (negations-are-props fe)

   ‚â†0‚Ñö-is-prop : (p : ‚Ñö) ‚Üí is-prop (p ‚â† 0‚Ñö)
   ‚â†0‚Ñö-is-prop p p‚â†‚ÇÅ0 p‚â†‚ÇÇ0 = nfe-by-fe fe (Œª x ‚Üí ùüò-elim (p‚â†‚ÇÅ0 x))

   -- Must be somewhere!
   ‚Ñö-dec-eq : (p q : ‚Ñö) ‚Üí (p Ôºù q) ‚àî (p ‚â† q)
   ‚Ñö-dec-eq p q with ‚Ñö-trichotomous fe p q
   ... | inl p<q = inr (Œª {refl ‚Üí ‚Ñö<-not-itself p p<q})
   ... | inr (inl pÔºùq) = inl pÔºùq
   ... | inr (inr p>q) = inr (Œª {refl ‚Üí ‚Ñö<-not-itself p p>q})

   ‚Ñö*-no-zero-divisors : (p q : ‚Ñö) ‚Üí (p ‚Ñö* q Ôºù 0‚Ñö) ‚Üí
     (p Ôºù 0‚Ñö) ‚àî (q Ôºù 0‚Ñö)
   ‚Ñö*-no-zero-divisors p q p*q=0 with ‚Ñö-dec-eq q 0‚Ñö
   ... | inl q=0 = inr q=0
   ... | inr q‚â†0 = inl
     (p
        Ôºù‚ü® ‚Ñö-mult-right-id fe p  ‚Åª¬π  ‚ü©
      p ‚Ñö* 1‚Ñö
        Ôºù‚ü® ap (p ‚Ñö*_) (qq'1 ‚Åª¬π) ‚ü©
      p ‚Ñö* (q ‚Ñö* q')
        Ôºù‚ü® ‚Ñö*-assoc fe p q q' ‚Åª¬π ‚ü©
      (p ‚Ñö* q ) ‚Ñö* q'
        Ôºù‚ü® ap (_‚Ñö* q') p*q=0 ‚ü©
      0‚Ñö ‚Ñö* q'
        Ôºù‚ü® ‚Ñö-zero-left-is-zero fe q' ‚ü©
      0‚Ñö ‚àé)
     where
       q-inv : Œ£ q' Íûâ ‚Ñö , q ‚Ñö* q' Ôºù 1‚Ñö
       q-inv = ‚Ñö*-inverse fe q q‚â†0
       q' : ‚Ñö
       q' = pr‚ÇÅ q-inv
       qq'1 : q ‚Ñö* q' Ôºù 1‚Ñö
       qq'1 = pr‚ÇÇ q-inv

   ‚Ñö-one-not-zero : 1‚Ñö ‚â† 0‚Ñö
   ‚Ñö-one-not-zero 1=0 = ‚Ñö-zero-not-one fe (1=0 ‚Åª¬π)

   multiplicative-‚Ñö : Group ùì§‚ÇÄ
   multiplicative-‚Ñö
     = ‚Ñö‚àò
     , (Œª (p , p‚â†0) (q , q‚â†0) ‚Üí (p ‚Ñö* q)
       , cases
           p‚â†0
           q‚â†0
           ‚àò (‚Ñö*-no-zero-divisors p q) )
     , ‚Ñö‚àò-is-set
     , (Œª (x , _) (y , _) (z , _) ‚Üí
          to-subtype-Ôºù
            ‚â†0‚Ñö-is-prop
            (‚Ñö*-assoc fe x y z))
     , (1‚Ñö , ‚Ñö-one-not-zero)
     , (Œª (x , _) ‚Üí to-subtype-Ôºù
         ‚â†0‚Ñö-is-prop
         (‚Ñö-mult-left-id fe x))
     , (Œª (x , _) ‚Üí to-subtype-Ôºù
         ‚â†0‚Ñö-is-prop
         (‚Ñö-mult-right-id fe x))
     , Œª (x , x‚â†0) ‚Üí
         let x' = multiplicative-inverse fe x x‚â†0
         in (x'
         , Œª x'=0 ‚Üí ‚Ñö-one-not-zero
           (1‚Ñö
              Ôºù‚ü® ‚Ñö*-inverse-product-is-one fe x x‚â†0 ‚Åª¬π ‚ü©
            x ‚Ñö* x'
              Ôºù‚ü® ap (x ‚Ñö*_) x'=0 ‚ü©
            (x ‚Ñö* 0‚Ñö)
              Ôºù‚ü® ‚Ñö-zero-right-is-zero fe x ‚ü©
            0‚Ñö ‚àé))
       , to-subtype-Ôºù
           ‚â†0‚Ñö-is-prop
           (x' ‚Ñö* x
             Ôºù‚ü® ‚Ñö*-comm x' x ‚ü©
           x ‚Ñö* x'
             Ôºù‚ü® ‚Ñö*-inverse-product-is-one fe x x‚â†0 ‚ü©
            1‚Ñö ‚àé)
       , to-subtype-Ôºù
           ‚â†0‚Ñö-is-prop
           (‚Ñö*-inverse-product-is-one fe x x‚â†0)

   ‚Ñö‚àò-pos : ùìü ‚Ñö‚àò
   ‚Ñö‚àò-pos (p , _) = 0‚Ñö < p , ‚Ñö<-is-prop 0‚Ñö p

   instance
     canonical-map-‚Ñö‚àò-to-‚Ñö : Canonical-Map ‚Ñö‚àò ‚Ñö
     Œπ {{canonical-map-‚Ñö‚àò-to-‚Ñö}} = pr‚ÇÅ


   open import DedekindReals.Symmetry.Subgroups pe pt fe
   open import DedekindReals.Symmetry.Subactions pe fe

   -- This ought to be in Rationals.Order
   ‚Ñö-pos-non-zero : (p : ‚Ñö) ‚Üí (p>0 : 0‚Ñö < p) ‚Üí ¬¨ (p Ôºù 0‚Ñö)
   ‚Ñö-pos-non-zero p p>0 p=0 = ‚Ñö<-not-itself 0‚Ñö (transport (0‚Ñö <_) p=0 p>0)

   multiplicative-‚Ñö+-subgroup
     : Subgroups' multiplicative-‚Ñö
   multiplicative-‚Ñö+-subgroup = ‚Ñö‚àò-pos ,
     ( lift _ (0 , refl)
     , (Œª p q p>0 q>0 ‚Üí
         (‚Ñö<-pos-multiplication-preserves-order
           (Œπ p) (Œπ q) p>0 q>0))
     , (Œª { (p , p‚â†0) p>0 ‚Üí
            (multiplicative-inverse-preserves-pos fe
              p (p>0) p‚â†0)
          }))

   multiplicative-‚Ñö+ : Group ùì§‚ÇÄ
   multiplicative-‚Ñö+ = induced-group' multiplicative-‚Ñö multiplicative-‚Ñö+-subgroup

   open import DedekindReals.Addition pe pt fe
     renaming (_+_ to _‚Ñù+_; -_ to ‚Ñù-_)
   additive-‚Ñù' : Group ùì§‚ÇÅ
   -- TODO: transport structure
   additive-‚Ñù'
     = ‚Ñù'
     , (Œª r s ‚Üí ‚åú ‚Ñù‚âÉ‚Ñù' ‚åù (‚åú ‚Ñù‚âÉ‚Ñù' ‚åù‚Åª¬π r ‚Ñù+ ‚åú ‚Ñù‚âÉ‚Ñù' ‚åù‚Åª¬π s))
     , ‚Ñù'-is-set
     , {!
     !}
     , Œπ 0‚Ñù
     , {!!}
     , {!!}
     , Œª x ‚Üí
       (Œπ (‚Ñù- Œπ x))
     , {!!}
     , {!!}

   ‚Ñö+'‚à£‚Ñù' : Action' additive-‚Ñö
   ‚Ñö+'‚à£‚Ñù'
     = ‚Ñù'
     , (Œª lp r ‚Üí Œπ lp ¬∑‚ü® additive-‚Ñù' ‚ü© r)
     , ‚Ñù'-is-set
     , {!!}
     , {!!}

   ‚Ñö‚Çä : ùì§‚ÇÄ Ãá
   ‚Ñö‚Çä = ‚ü® multiplicative-‚Ñö+ ‚ü©

   instance
     canonical-map-‚Ñö‚Çä-to-‚Ñö : Canonical-Map ‚Ñö‚Çä ‚Ñö
     Œπ {{canonical-map-‚Ñö‚Çä-to-‚Ñö}} = pr‚ÇÅ ‚àò pr‚ÇÅ

   -- can do away with some of the projection reshuffling if
   -- we define the monoid action instead

   -- It's easier to go this way :(
   ‚Ñö‚àò* : Group ùì§‚ÇÄ
   ‚Ñö‚àò* = multiplicative-‚Ñö

   ‚Ñö‚Çä*‚óÉ‚Ñö*' : Subgroups' multiplicative-‚Ñö
   ‚Ñö‚Çä*‚óÉ‚Ñö*' = ‚Ñö‚àò-pos
     , (unit-closed' multiplicative-‚Ñö multiplicative-‚Ñö+-subgroup)
     , (mult-closed' multiplicative-‚Ñö multiplicative-‚Ñö+-subgroup)
     , (inv-closed' multiplicative-‚Ñö multiplicative-‚Ñö+-subgroup)


   ‚Ñö‚Çä* : Group ùì§‚ÇÄ
   ‚Ñö‚Çä* = induced-group' multiplicative-‚Ñö ‚Ñö‚Çä*‚óÉ‚Ñö*'

   scale-pred : ‚ü® multiplicative-‚Ñö ‚ü© ‚Üí ùìü ‚Ñö ‚Üí ùìü ‚Ñö
   scale-pred p P q
       -- This way around works better with left actions
     = P (pr‚ÇÅ (inv multiplicative-‚Ñö p) ‚Ñö* q)

   ‚Ñö‚àò*‚à£‚Ñö : Action (‚Ñö‚àò* ·µí·µñ)
   ‚Ñö‚àò*‚à£‚Ñö
     = ‚Ñö
     , (Œª pnz x ‚Üí pr‚ÇÅ (inv ‚Ñö‚àò* pnz) ‚Ñö* x)
     , ‚Ñö-is-set fe
     , (Œª pnz@(p , p‚â†0) qnz@(q , q‚â†0) x ‚Üí
       let (p' , _) = inv ‚Ñö‚àò* pnz
           (q' , _) = inv ‚Ñö‚àò* qnz
       in pr‚ÇÅ (inv ‚Ñö‚àò* (qnz ¬∑‚ü® ‚Ñö‚àò* ‚ü© pnz)) ‚Ñö* x
                Ôºù‚ü® ap (Œª r ‚Üí (pr‚ÇÅ r) ‚Ñö* x)
                    (inv-reverses-multiplication
                    ‚Ñö‚àò* qnz pnz) ‚ü©
              (p' ‚Ñö* q') ‚Ñö* x
                Ôºù‚ü® ‚Ñö*-assoc fe p' q' x ‚ü©
              p' ‚Ñö* (q' ‚Ñö* x)  ‚àé)
     , Œª x ‚Üí pr‚ÇÅ (inv ‚Ñö‚àò* (unit ‚Ñö‚àò*)) ‚Ñö* x
         Ôºù‚ü® ap (Œª r ‚Üí pr‚ÇÅ r ‚Ñö* x)
                (inv-unit-unit ‚Ñö‚àò*)  ‚ü©
         1‚Ñö ‚Ñö* x
         Ôºù‚ü® ‚Ñö-mult-left-id fe x  ‚ü©
         x ‚àé

   open GroupConstructions

   -- Now starts the real work, hopefully
   ‚Ñö*'‚à£ùìü‚Ñö : Action' ‚Ñö‚àò*
   ‚Ñö*'‚à£ùìü‚Ñö = RelLiftAction·µí·µñ ‚Ñö‚àò* ‚Ñö‚àò*‚à£‚Ñö

   ‚Ñö‚Çä*‚à£ùìü‚Ñö : Action' ‚Ñö‚Çä*
   ‚Ñö‚Çä*‚à£ùìü‚Ñö = induced-action ‚Ñö‚àò* ‚Ñö‚Çä*‚óÉ‚Ñö*' ‚Ñö*'‚à£ùìü‚Ñö

   ‚Ñö‚Çä*‚à£ùìü‚Ñö-inhabited-invariant :
     prop-is-invariant ‚Ñö‚Çä*
                       ‚Ñö‚Çä*‚à£ùìü‚Ñö
                       inhabited-pred
   ‚Ñö‚Çä*‚à£ùìü‚Ñö-inhabited-invariant ((g , g‚â†0) , g>0) L
     = let (g'' , g''‚â†0) = inv multiplicative-‚Ñö (g , g‚â†0)
       in (‚à•‚à•-induction
       (Œª _ ‚Üí ‚àÉ-is-prop)
       Œª (p , Lp) ‚Üí
       let u : ‚ü® L (g'' ‚Ñö* (g ‚Ñö* p)) ‚ü©
           u = transport (Œª ‚Ñì ‚Üí ‚ü® L ‚Ñì ‚ü©)
               (p
                  Ôºù‚ü® ‚Ñö-mult-left-id fe p ‚Åª¬π ‚ü©
                1‚Ñö ‚Ñö* p
                  Ôºù‚ü® ap (_‚Ñö* p)
                      (ap pr‚ÇÅ
                      (inv-left multiplicative-‚Ñö
                        (g , g‚â†0))
                      ‚Åª¬π) ‚ü©
                (g'' ‚Ñö* g) ‚Ñö* p
                  Ôºù‚ü® ‚Ñö*-assoc fe g'' g p ‚ü©
                g'' ‚Ñö* (g ‚Ñö* p) ‚àé
               )
               Lp
       in ‚à£ g ‚Ñö* p  , u ‚à£)

   pr-‚áí : {ùì§ ùì• : Universe} {p : Œ© ùì§} ‚Üí {q : Œ© ùì•}  ‚Üí
     ‚ü® p ‚áîŒ© q ‚ü© ‚Üí ‚ü® p ‚áíŒ© q ‚ü©
   pr-‚áí = pr‚ÇÅ

   pr-‚áê : {ùì§ ùì• : Universe} {p : Œ© ùì§}  ‚Üí {q : Œ© ùì•}  ‚Üí
     ‚ü® p ‚áîŒ© q ‚ü© ‚Üí ‚ü® q ‚áíŒ© p ‚ü©
   pr-‚áê = pr‚ÇÇ

   -1‚Ñö<0 : - 1‚Ñö < 0‚Ñö
   -1‚Ñö<0 = ‚Ñö<-negative-is-negative 0 1

   -1‚Ñö‚â†0 : ¬¨ (- 1‚Ñö Ôºù 0‚Ñö)
   -1‚Ñö‚â†0 -1‚Ñö=0‚Ñö = ‚Ñö<-not-itself (- 1‚Ñö)
     (transport ((- 1‚Ñö) <‚Ñö_) (-1‚Ñö=0‚Ñö ‚Åª¬π) -1‚Ñö<0)

   ‚Ñö<-pos-multiplication-monotone : (p q q' : ‚Ñö) ‚Üí p > 0‚Ñö ‚Üí
     q < q' ‚Üí p ‚Ñö* q < p ‚Ñö* q'
   ‚Ñö<-pos-multiplication-monotone p q q' p>0 q<q'
     = p ‚Ñö* q
       Ôºù‚ü® unit-right additive-‚Ñö (p ‚Ñö* q) ‚Åª¬π ‚ü©
       (p ‚Ñö* q ‚Ñö+ 0‚Ñö)
       ‚â∫‚ü® _<_ ‚à£
         ‚Ñö<-addition-preserves-order-left
         (p ‚Ñö* q) 0‚Ñö (p ‚Ñö* ((- q) ‚Ñö+ q')) 0<p[-q+q'] ‚ü©
       (p ‚Ñö* q ‚Ñö+ (p ‚Ñö* ((- q) ‚Ñö+ q')))
         Ôºù‚ü® pq+p[-q+q']=pq' ‚ü©
       p ‚Ñö* q'  ‚àé

     where
       0<-q+q' : 0‚Ñö < (- q) ‚Ñö+ q'
       0<-q+q' =
         0‚Ñö
           Ôºù‚ü® inv-left additive-‚Ñö q ‚Åª¬π ‚ü©
         (- q) ‚Ñö+ q
           ‚â∫‚ü® _<_ ‚à£ ‚Ñö<-addition-preserves-order-left
             (- q) q q' q<q' ‚ü©
         (- q) ‚Ñö+ q'
           Ôºù‚ü® refl ‚ü©
         (- q) ‚Ñö+ q' ‚àé
       0<p[-q+q'] : 0‚Ñö < p ‚Ñö* ((- q) ‚Ñö+ q')
       0<p[-q+q'] = ‚Ñö<-pos-multiplication-preserves-order
                  p ((- q) ‚Ñö+ q') p>0 0<-q+q'
       pq+p[-q+q']=pq' :
         p ‚Ñö* q ‚Ñö+ (p ‚Ñö* ((- q) ‚Ñö+ q')) Ôºù p ‚Ñö* q'
       pq+p[-q+q']=pq' =
         p ‚Ñö* q ‚Ñö+ (p ‚Ñö* ((- q) ‚Ñö+ q'))
            Ôºù‚ü® ‚Ñö-distributivity fe
                 p q ((- q) ‚Ñö+ q') ‚Åª¬π ‚ü©
          p ‚Ñö* (q ‚Ñö+ ((- q) ‚Ñö+ q'))
            Ôºù‚ü® ap (p ‚Ñö*_) (assoc additive-‚Ñö q (- q) q' ‚Åª¬π) ‚ü©
          p ‚Ñö* ((q ‚Ñö+ (- q)) ‚Ñö+ q')
            Ôºù‚ü® ap (Œª u ‚Üí p ‚Ñö*(u ‚Ñö+ q'))
                (inv-right additive-‚Ñö q) ‚ü©
          p ‚Ñö* (0‚Ñö ‚Ñö+ q')
            Ôºù‚ü® ap (p ‚Ñö*_) (unit-left additive-‚Ñö q') ‚ü©
          p ‚Ñö* q' ‚àé

   ‚Ñö-negate-equation : (a b : ‚Ñö) ‚Üí a < b ‚Üí - b < - a
   ‚Ñö-negate-equation a b a<b =
     - b
       Ôºù‚ü® -- calculate as follows:
           - b
             Ôºù‚ü® unit-right additive-‚Ñö (- b) ‚Åª¬π ‚ü©
           (- b) ‚Ñö+ 0‚Ñö
             Ôºù‚ü® ap ((- b) ‚Ñö+_)
                 (inv-right additive-‚Ñö a ‚Åª¬π) ‚ü©
           (- b) ‚Ñö+ (a ‚Ñö+ (- a))
             Ôºù‚ü® assoc additive-‚Ñö (- b) a (- a) ‚Åª¬π ‚ü©
           ((- b) ‚Ñö+ a) ‚Ñö+ (- a) ‚àé
         ‚ü©
     ((- b) ‚Ñö+ a) ‚Ñö+ (- a)
       ‚â∫‚ü® _<_ ‚à£ ‚Ñö<-addition-preserves-order-right
                 (( - b) ‚Ñö+ a) ((- b) ‚Ñö+ b) (- a)
                 (‚Ñö<-addition-preserves-order-left
                 (- b) a b a<b) ‚ü©
     ((- b) ‚Ñö+ b) ‚Ñö+ (- a)
       Ôºù‚ü® -- calculate as follows:
           ((- b) ‚Ñö+ b) ‚Ñö+ (- a)
             Ôºù‚ü® ap (_‚Ñö+ (- a))
                (inv-left additive-‚Ñö b) ‚ü©
           0‚Ñö ‚Ñö+ (- a)
             Ôºù‚ü® unit-left additive-‚Ñö (- a) ‚ü©
           - a ‚àé
         ‚ü©
     - a ‚àé


   ‚Ñö<-neg-multiplication-antitone : (p q q' : ‚Ñö) ‚Üí p < 0‚Ñö ‚Üí
     q < q' ‚Üí p ‚Ñö* q > p ‚Ñö* q'
   ‚Ñö<-neg-multiplication-antitone p q q' p<0 q<q' =
     (p ‚Ñö* q')
       Ôºù‚ü® ‚Ñö*-minus-minus fe p q' ‚Åª¬π ‚ü©
     (- p) ‚Ñö* (- q')
       ‚â∫‚ü® _<_ ‚à£ -p*-q'<-p*-q ‚ü©
     (- p) ‚Ñö* (- q)
       Ôºù‚ü® ‚Ñö*-minus-minus fe p q ‚ü©
     p ‚Ñö* q ‚àé
     where
       -q'<-q : - q' < - q
       -q'<-q = ‚Ñö-negate-equation q q' q<q'
       -p>0 : - p > 0‚Ñö
       -p>0 = ‚Ñö-negate-equation p 0‚Ñö p<0
       -p*-q'<-p*-q : (- p) ‚Ñö* (- q') < (- p) ‚Ñö* (- q)
       -p*-q'<-p*-q = ‚Ñö<-pos-multiplication-monotone
          (- p) (- q') (- q) -p>0 -q'<-q

   ‚Ñö-mult-minus-one-negates : (p : ‚Ñö) ‚Üí
     (- 1‚Ñö) ‚Ñö* p Ôºù - p
   ‚Ñö-mult-minus-one-negates p =
     (- 1‚Ñö) ‚Ñö* p
        Ôºù‚ü® ‚Ñö-negation-dist-over-mult-left fe 1‚Ñö p ‚ü©
     - (1‚Ñö ‚Ñö* p)
                -- need to use multiplicative monoid
                -- structure we haven't defined
        Ôºù‚ü® ap -_ (‚Ñö-mult-left-id fe p) ‚ü©
     - p ‚àé


   ‚Ñö<-neg-antitone : (p q : ‚Ñö) ‚Üí
     p < q ‚Üí (- q) < (- p)
   ‚Ñö<-neg-antitone p q p<q =
     - q
       Ôºù‚ü® ‚Ñö-mult-minus-one-negates q ‚Åª¬π ‚ü©
     (- 1‚Ñö) ‚Ñö* q
       ‚â∫‚ü® _<_ ‚à£ ‚Ñö<-neg-multiplication-antitone
                (- 1‚Ñö) p q -1‚Ñö<0 p<q ‚ü©
     (- 1‚Ñö) ‚Ñö* p
       Ôºù‚ü® ‚Ñö-mult-minus-one-negates p ‚ü©
     - p ‚àé



   -- TODO: maybe we can use symmetric programming to
   -- discharge these?

   p/q<l‚áîp<ql : (((q , q‚â†0) , q>0) : ‚ü® ‚Ñö‚Çä* ‚ü©) ‚Üí (p r : ‚Ñö) ‚Üí
         ‚ü® ‚Ñö< (Œπ (inv multiplicative-‚Ñö (q , q‚â†0)) ‚Ñö* p , r) ‚áîŒ©
          (‚Ñö< (p , q ‚Ñö* r)) ‚ü©
   p/q<l‚áîp<ql ((q , q‚â†0) , q>0) p r
     = let ((q' , q'‚â†0) , q'>0)  = inv ‚Ñö‚Çä* ((q , q‚â†0) , q>0) in
       (Œª p/q<r ‚Üí
         p
         Ôºù[ --calculate:
             p
               Ôºù‚ü® ‚Ñö-mult-left-id fe p ‚Åª¬π ‚ü©
             1‚Ñö ‚Ñö* p
               Ôºù‚ü® ap (Œª x ‚Üí Œπ x ‚Ñö* p)
                    (inv-right ‚Ñö‚àò* (q , q‚â†0)) ‚Åª¬π ‚ü©
             (q ‚Ñö* q') ‚Ñö* p
               Ôºù‚ü® ‚Ñö*-assoc fe q q' p ‚ü©
             q ‚Ñö* (q' ‚Ñö* p) ‚àé
           ]
         q ‚Ñö* (q' ‚Ñö* p)
           ‚â∫‚ü® _<_ ‚à£ ‚Ñö<-pos-multiplication-monotone
                    q (q' ‚Ñö* p) r q>0 p/q<r ‚ü©
         q ‚Ñö* r ‚àé)
     , Œª p<qr ‚Üí
         q' ‚Ñö* p
           ‚â∫‚ü® _<_ ‚à£ ‚Ñö<-pos-multiplication-monotone
                    q' p (q ‚Ñö* r) q'>0 p<qr ‚ü©
         q' ‚Ñö* (q ‚Ñö* r)
           Ôºù[ -- calculate
               q' ‚Ñö* (q ‚Ñö* r)
                 Ôºù‚ü® ‚Ñö*-assoc fe q' q r ‚Åª¬π ‚ü©
               (q' ‚Ñö* q) ‚Ñö* r
                 Ôºù‚ü® ap (Œª x ‚Üí Œπ x ‚Ñö* r)
                     (inv-left ‚Ñö‚àò* (q , q‚â†0)) ‚ü©
               1‚Ñö ‚Ñö* r
                 Ôºù‚ü® ‚Ñö-mult-left-id fe r ‚ü©
               r ‚àé ]
         r ‚àé

   x‚ààpL‚áîx/p‚ààL : (x p : ‚Ñö) ‚Üí (L : ùìü ‚Ñö) ‚Üí
     (p‚â†0 : ¬¨ (p Ôºù 0‚Ñö)) ‚Üí
     ‚ü® ((p , p‚â†0) ‚óÇ‚ü® multiplicative-‚Ñö ‚à£ ‚Ñö*'‚à£ùìü‚Ñö ‚ü© L) x ‚áîŒ©
       L ( Œπ (inv multiplicative-‚Ñö (p , p‚â†0)) ‚Ñö* x) ‚ü©
   x‚ààpL‚áîx/p‚ààL x p L p‚â†0
     = id
     , id


   ‚Ñö‚Çä*‚à£ùìü‚Ñö-rounded-invariant :
     prop-is-invariant ‚Ñö‚Çä*
                       ‚Ñö‚Çä*‚à£ùìü‚Ñö
                       (rounded-wrt ‚Ñö<)
   ‚Ñö‚Çä*‚à£ùìü‚Ñö-rounded-invariant gp@((g , g‚â†0) , g>0) L L-rounded p
     = let ((g' , g'‚â†0), g'>0) = inv ‚Ñö‚Çä* gp
           (Lg'p‚áí‚àÉ , Lg'p‚áê‚àÉ) = L-rounded (g' ‚Ñö* p)
       in
       (Œª Lg'p ‚Üí ‚à•‚à•-induction
                  (Œª _ ‚Üí ‚àÉ-is-prop)
                  (Œª (q , g'p<q , Lq) ‚Üí
                    ‚à£ g ‚Ñö* q
                      , pr-‚áí (p/q<l‚áîp<ql gp p q) g'p<q
                        -- we have Lq
                        -- we need L(g' * (g * q))
                      , transport (Œª x ‚Üí ‚ü® L x ‚ü©)
                          (q
                            Ôºù‚ü® ‚Ñö-mult-left-id fe q ‚Åª¬π ‚ü©
                          1‚Ñö ‚Ñö* q
                            Ôºù‚ü® ap (Œª x ‚Üí Œπ x ‚Ñö* q)
                            (inv-left multiplicative-‚Ñö
                              (g , g‚â†0)) ‚Åª¬π ‚ü©
                          (g' ‚Ñö* g) ‚Ñö* q
                          Ôºù‚ü® ‚Ñö*-assoc fe g' g q ‚ü©
                           g' ‚Ñö* (g ‚Ñö* q) ‚àé)
                          Lq ‚à£)
                  (Lg'p‚áí‚àÉ Lg'p))
       , ‚à•‚à•-induction
           (Œª _ ‚Üí holds-is-prop (L (pr‚ÇÅ (inv ‚Ñö‚àò* (g , g‚â†0)) ‚Ñö* p)))
           (Œª (q , p<q , Lg'q) ‚Üí
                 (Lg'p‚áê‚àÉ ‚à£ g' ‚Ñö* q
                 , ‚Ñö<-pos-multiplication-monotone
                     g' p q g'>0 p<q
                 , Lg'q ‚à£ ))

   S‚ÇÇ·µí·µñ‚à£‚Ñö : Action (S‚ÇÇ ·µí·µñ)
   S‚ÇÇ·µí·µñ‚à£‚Ñö
     = ‚Ñö
     , (Œª { id‚ààS‚ÇÇ x ‚Üí x
          ; flip  x ‚Üí - x
          })
     , ‚Ñö-is-set fe
     , (Œª { g id‚ààS‚ÇÇ x ‚Üí refl
          ; id‚ààS‚ÇÇ flip x ‚Üí refl
          ; flip flip x ‚Üí ‚Ñö-minus-minus fe x
          })
     , Œª x ‚Üí refl

   S‚ÇÇ‚à£ùìü‚Ñö : Action' S‚ÇÇ
   S‚ÇÇ‚à£ùìü‚Ñö = RelLiftAction·µí·µñ S‚ÇÇ S‚ÇÇ·µí·µñ‚à£‚Ñö

   -- The point: rounded-right is not invariant, but rounded-wrt it

   ‚Ñö‚ñ° : ùìü (Rel)
   ‚Ñö‚ñ° = ((only (ùìü-is-set' fe pe) ‚Ñö<) ‚äï
          (only (ùìü-is-set' fe pe) ‚Ñö>))
          -- Show that ‚Ñö< ‚â† ‚Ñö>
          Œª { .‚Ñö< (refl , ‚Ñö>=‚Ñö<) ‚Üí ‚Ñö<-not-itself 0‚Ñö
            (‚Ñö<-trans 0‚Ñö 1‚Ñö 0‚Ñö
              (‚Ñö-zero-less-than-positive 0 1)
              (transport (Œª P ‚Üí ‚ü® P (1‚Ñö , 0‚Ñö) ‚ü©)
                ‚Ñö>=‚Ñö<
                (‚Ñö-zero-less-than-positive 0 1)))}


   S‚ÇÇ‚à£‚Ñö‚ñ°‚óÉRel : prop-is-invariant S‚ÇÇ S‚ÇÇ‚à£Rel ‚Ñö‚ñ°
   S‚ÇÇ‚à£‚Ñö‚ñ°‚óÉRel id‚ààS‚ÇÇ P prf = prf
   S‚ÇÇ‚à£‚Ñö‚ñ°‚óÉRel flip .‚Ñö< (inl refl) = inr refl
   S‚ÇÇ‚à£‚Ñö‚ñ°‚óÉRel flip .(opposite ‚Ñö<) (inr refl)
     = inl refl

   S‚ÇÇ‚à£‚Ñö‚ñ° : Action' S‚ÇÇ
   S‚ÇÇ‚à£‚Ñö‚ñ° = subaction S‚ÇÇ S‚ÇÇ‚à£Rel ‚Ñö‚ñ° S‚ÇÇ‚à£‚Ñö‚ñ°‚óÉRel

   -- Plan:

   S‚ÇÇ'‚à£‚Ñö‚ñ°√óùìü‚Ñö : Action' S‚ÇÇ
   S‚ÇÇ'‚à£‚Ñö‚ñ°√óùìü‚Ñö = S‚ÇÇ‚à£‚Ñö‚ñ° ‚äô S‚ÇÇ‚à£ùìü‚Ñö

   -- There ought to be a proof using the fact that
   -- the logical connectives are equivariant in some sense
   rounded-wrt-invariant-wrt-flip-‚Ñö< :
     (L : ùìü ‚Ñö) ‚Üí
     prop-is-invariant-wrt-at
       S‚ÇÇ S‚ÇÇ'‚à£‚Ñö‚ñ°√óùìü‚Ñö
       (Œª {((R , ‚Ñö<‚à®‚Ñö>) , L) ‚Üí rounded-wrt R  L })
       flip
       ((‚Ñö< , inl refl) , L)
   rounded-wrt-invariant-wrt-flip-‚Ñö< L L-rounded p
     = (Œª L-p ‚Üí ‚à•‚à•-induction
         (Œª _ ‚Üí ‚àÉ-is-prop)
         (Œª (q , -p<q , Lq) ‚Üí
           ‚à£ - q
           , - q
                 ‚â∫‚ü® _<_ ‚à£ ‚Ñö<-neg-antitone (- p) q -p<q ‚ü©
               - (- p)
                 Ôºù[ ‚Ñö-minus-minus fe p ‚Åª¬π ]
               p ‚àé
           , transport (Œª r ‚Üí ‚ü® L r ‚ü©)
               (‚Ñö-minus-minus fe q)
               Lq  ‚à£)
         (pr-‚áí (L-rounded (- p)) L-p))
     , ‚à•‚à•-induction
          (Œª _ ‚Üí holds-is-prop
            ((flip ‚óÇ‚ü® S‚ÇÇ ‚à£ S‚ÇÇ‚à£ùìü‚Ñö ‚ü© L)  p))
          Œª (q , q<p , L-q) ‚Üí
            pr-‚áê (L-rounded (- p))
                 ‚à£ - q , ‚Ñö<-neg-antitone q p q<p , L-q ‚à£
   -- blech, we ought to use symmetry
   rounded-wrt-invariant-wrt-flip-‚Ñö> :
     (L : ùìü ‚Ñö) ‚Üí
     prop-is-invariant-wrt-at
       S‚ÇÇ S‚ÇÇ'‚à£‚Ñö‚ñ°√óùìü‚Ñö
       (Œª {((R , ‚Ñö<‚à®‚Ñö>) , L) ‚Üí rounded-wrt R  L })
       flip
       ((‚Ñö> , inr refl) , L)
   rounded-wrt-invariant-wrt-flip-‚Ñö> L L-rounded p
     = (Œª L-p ‚Üí ‚à•‚à•-induction
         (Œª _ ‚Üí ‚àÉ-is-prop)
         (Œª (q , -p>q , Lq) ‚Üí
           ‚à£ - q
           ,  - q
                 ‚â∫‚ü® _>_ ‚à£ ‚Ñö<-neg-antitone q (- p) -p>q ‚ü©
               - (- p)
                 Ôºù[ ‚Ñö-minus-minus fe p ‚Åª¬π ]
               p ‚àé
           ,  transport (Œª r ‚Üí ‚ü® L r ‚ü©)
               (‚Ñö-minus-minus fe q)
               Lq  ‚à£)
         (pr-‚áí (L-rounded (- p)) L-p))
     , ‚à•‚à•-induction
          (Œª _ ‚Üí holds-is-prop
            ((flip ‚óÇ‚ü® S‚ÇÇ ‚à£ S‚ÇÇ‚à£ùìü‚Ñö ‚ü© L)  p))
          Œª (q , q<p , L-q) ‚Üí
            pr-‚áê (L-rounded (- p))
                 ‚à£ - q ,  ‚Ñö<-neg-antitone p q q<p  , L-q ‚à£

   rounded-wrt-invariant :
     prop-is-invariant S‚ÇÇ
                       S‚ÇÇ'‚à£‚Ñö‚ñ°√óùìü‚Ñö
                       Œª {((R , ‚Ñö<‚à®‚Ñö>) , L) ‚Üí
                         rounded-wrt R  L }
   rounded-wrt-invariant id‚ààS‚ÇÇ ((R , ‚Ñö<‚à®‚Ñö>) , L) L-rounded
     = L-rounded
   rounded-wrt-invariant flip ((.‚Ñö< , inl refl) , L) L-‚Ñö<-rounded
     = rounded-wrt-invariant-wrt-flip-‚Ñö< L L-‚Ñö<-rounded
   rounded-wrt-invariant flip ((.‚Ñö> , inr refl) , L) L-‚Ñö>-rounded
     = rounded-wrt-invariant-wrt-flip-‚Ñö> L L-‚Ñö>-rounded



   -- The reason this argument works:
   S‚ÇÇ-‚Ñö‚Çä*-commute :
     actions-commute S‚ÇÇ ‚Ñö‚Çä* S‚ÇÇ‚à£ùìü‚Ñö ‚Ñö‚Çä*‚à£ùìü‚Ñö
   S‚ÇÇ-‚Ñö‚Çä*-commute id‚ààS‚ÇÇ ((h , h‚â†0) , h>0) L = refl
   S‚ÇÇ-‚Ñö‚Çä*-commute flip hp@((h , h‚â†0) , h>0) L = nfe-by-fe fe Œª p ‚Üí
     let ((h' , h'‚â†0) , h'>0) = inv ‚Ñö‚Çä* hp in
     ap  L (
        h' ‚Ñö* (- p)
       Ôºù‚ü® ‚Ñö-negation-dist-over-mult-right fe h' p ‚ü©
       - (h' ‚Ñö* p) ‚àé
        )

   S‚ÇÇ‚äó‚Ñö‚Çä*‚à£ùìü‚Ñö : Action' (S‚ÇÇ ‚äó ‚Ñö‚Çä*)
   S‚ÇÇ‚äó‚Ñö‚Çä*‚à£ùìü‚Ñö = merge S‚ÇÇ       S‚ÇÇ‚à£ùìü‚Ñö
                         ‚Ñö‚Çä* ‚Ñö‚Çä*‚à£ùìü‚Ñö
                         S‚ÇÇ-‚Ñö‚Çä*-commute

   ‚Ñö‚Çä*‚à£ùìü‚Ñö-rounded-right-invariant :
     prop-is-invariant ‚Ñö‚Çä* ‚Ñö‚Çä*‚à£ùìü‚Ñö
                       (rounded-wrt ‚Ñö>)

   ‚Ñö‚Çä*‚à£ùìü‚Ñö-rounded-right-invariant
     g@((g‚ÇÄ , g‚â†0) , g>0) L L-rounded-right p
     = transport rounded-right [g‚óÇL·µí·µñ]·µí·µñ=g‚óÇL
       [g‚óÇL·µí·µñ]·µí·µñ-rounded-right p
     where
       L·µí·µñ : ùìü ‚Ñö
       L·µí·µñ = flip ‚óÇ‚ü® S‚ÇÇ ‚à£ S‚ÇÇ‚à£ùìü‚Ñö ‚ü© L

       L·µí·µñ-rounded-left : rounded-left L·µí·µñ
       L·µí·µñ-rounded-left = rounded-wrt-invariant
                          flip ((‚Ñö> , inr refl) , L)
                          L-rounded-right
       g‚óÇL·µí·µñ : ùìü ‚Ñö
       g‚óÇL·µí·µñ = g ‚óÇ‚ü® ‚Ñö‚Çä* ‚à£ ‚Ñö‚Çä*‚à£ùìü‚Ñö ‚ü© L·µí·µñ
       g‚óÇL·µí·µñ-rounded-left : rounded-left g‚óÇL·µí·µñ
       g‚óÇL·µí·µñ-rounded-left
         = ‚Ñö‚Çä*‚à£ùìü‚Ñö-rounded-invariant g L·µí·µñ L·µí·µñ-rounded-left
       [g‚óÇL·µí·µñ]·µí·µñ : ùìü ‚Ñö
       [g‚óÇL·µí·µñ]·µí·µñ = flip ‚óÇ‚ü® S‚ÇÇ ‚à£ S‚ÇÇ‚à£ùìü‚Ñö ‚ü© g‚óÇL·µí·µñ
       [g‚óÇL·µí·µñ]·µí·µñ-rounded-right : rounded-right [g‚óÇL·µí·µñ]·µí·µñ
       [g‚óÇL·µí·µñ]·µí·µñ-rounded-right
         = rounded-wrt-invariant
                          flip ((‚Ñö< , inl refl) , g‚óÇL·µí·µñ)
                          g‚óÇL·µí·µñ-rounded-left
       g‚óÇL : ùìü ‚Ñö
       g‚óÇL = g ‚óÇ‚ü® ‚Ñö‚Çä* ‚à£  ‚Ñö‚Çä*‚à£ùìü‚Ñö ‚ü© L
       [g‚óÇL·µí·µñ]·µí·µñ=g‚óÇL : [g‚óÇL·µí·µñ]·µí·µñ Ôºù g‚óÇL
       [g‚óÇL·µí·µñ]·µí·µñ=g‚óÇL = nfe-by-fe fe (Œª p ‚Üí
         let ((g' , g'‚â†0) , g'>0) = inv ‚Ñö‚Çä* g
         in ap L
         (- (g' ‚Ñö* (- p))
           Ôºù‚ü® ap -_ (‚Ñö-negation-dist-over-mult-right fe g' p) ‚ü©
           - (- (g' ‚Ñö* p))
           Ôºù‚ü® ‚Ñö-minus-minus fe (g' ‚Ñö* p) ‚Åª¬π ‚ü©
           g' ‚Ñö* p ‚àé
         ))

   -- Should be done more generally

   ‚Ñö*'‚à£pre-cut-action : action-structure multiplicative-‚Ñö pre-cut
   ‚Ñö*'‚à£pre-cut-action lpnz r
     with (p , p‚â†0) ‚Üê lpnz | ‚Ñö-trichotomous fe p 0‚Ñö
   ... | inl p>0 = {!!}
   ... | inr p<0 = {!!}

   ‚Ñö*'‚à£pre-cut : Action' multiplicative-‚Ñö
   ‚Ñö*'‚à£pre-cut
     = pre-cut
     , (Œª lq x ‚Üí {!!})
     , {!!}
     , {!!}
     , {!!}
